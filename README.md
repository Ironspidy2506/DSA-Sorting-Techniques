
# 📚 Sorting Techniques

## 1. 🛁 Bubble Sort
- **Description**: Repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order.
- **Best Time Complexity**: O(n) (when the array is already sorted) 👍
- **Average Time Complexity**: O(n²) ⚖️
- **Worst Time Complexity**: O(n²) ❌

## 2. 📥 Insertion Sort
- **Description**: Builds a sorted array one element at a time by repeatedly picking the next element and inserting it into the correct position.
- **Best Time Complexity**: O(n) (when the array is already sorted) 👍
- **Average Time Complexity**: O(n²) ⚖️
- **Worst Time Complexity**: O(n²) ❌

## 3. ⚡ Quick Sort
- **Description**: Uses a divide-and-conquer approach to sort by selecting a 'pivot' element and partitioning the array around it.
- **Best Time Complexity**: O(n log n) 🌟
- **Average Time Complexity**: O(n log n) ⚖️
- **Worst Time Complexity**: O(n²) ❌

## 4. 🥡 Merge Sort
- **Description**: Divides the array into halves, sorts them, and then merges the sorted halves back together.
- **Best Time Complexity**: O(n log n) 🌟
- **Average Time Complexity**: O(n log n) ⚖️
- **Worst Time Complexity**: O(n log n) ❌

## 5. 🎯 Selection Sort
- **Description**: Divides the array into a sorted and an unsorted region, repeatedly selecting the smallest (or largest) element from the unsorted region.
- **Best Time Complexity**: O(n²) ❌
- **Average Time Complexity**: O(n²) ⚖️
- **Worst Time Complexity**: O(n²) ❌

## 6. 🧮 Counting Sort
- **Description**: Counting Sort works by counting the occurrences of each unique element in the input array and using this information to place the elements in their correct position in the sorted array.
- **Best Time Complexity**: O(n + k) 🌟 (where n is the number of elements and k is the range of the input)
- **Average Time Complexity**: O(n + k) ⚖️
- **Worst Time Complexity**: O(n + k) ❌
